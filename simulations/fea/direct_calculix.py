"""
Direct Calculix input generation for cantilever beam validation.
Bypasses pycalculix API issues.
"""
import subprocess
import os
import tempfile
import numpy as np

def create_cantilever_inp(width=70.0, height=30.0, length=47.5, force_n=180000.0):
    """Generate a Calculix .inp file for cantilever beam bending."""
    # Mesh: 2×2×2 elements for better stress distribution
    nx, ny, nz = 2, 2, 2
    dx = length / nx
    dy = width / ny
    dz = height / nz
    
    # Material: steel
    E = 210000.0  # MPa
    nu = 0.3
    density = 7.85e-9  # tonne/mm³ (Calculix units)
    
    inp = []
    inp.append("** Cantilever beam validation")
    inp.append("** Generated by direct_calculix.py")
    inp.append("*NODE")
    node_id = 1
    nodes = {}
    for ix in range(nx + 1):
        x = ix * dx
        for iy in range(ny + 1):
            y = iy * dy
            for iz in range(nz + 1):
                z = iz * dz
                inp.append(f"{node_id},{x:.6f},{y:.6f},{z:.6f}")
                nodes[(ix, iy, iz)] = node_id
                node_id += 1
    
    inp.append("*ELEMENT, TYPE=C3D8, ELSET=BEAM")
    elem_id = 1
    for ix in range(nx):
        for iy in range(ny):
            for iz in range(nz):
                n1 = nodes[(ix, iy, iz)]
                n2 = nodes[(ix+1, iy, iz)]
                n3 = nodes[(ix+1, iy+1, iz)]
                n4 = nodes[(ix, iy+1, iz)]
                n5 = nodes[(ix, iy, iz+1)]
                n6 = nodes[(ix+1, iy, iz+1)]
                n7 = nodes[(ix+1, iy+1, iz+1)]
                n8 = nodes[(ix, iy+1, iz+1)]
                inp.append(f"{elem_id},{n1},{n2},{n3},{n4},{n5},{n6},{n7},{n8}")
                elem_id += 1
    
    inp.append("*MATERIAL, NAME=STEEL")
    inp.append("*ELASTIC")
    inp.append(f"{E:.1f},{nu:.2f}")
    inp.append("*DENSITY")
    inp.append(f"{density:.6e}")
    
    inp.append("*SOLID SECTION, ELSET=BEAM, MATERIAL=STEEL")
    
    # Boundary condition: fix nodes at x=0 (fixed end)
    fixed_nodes = []
    for iy in range(ny + 1):
        for iz in range(nz + 1):
            fixed_nodes.append(nodes[(0, iy, iz)])
    inp.append("*NSET, NSET=FIXED")
    inp.append(",".join(str(n) for n in fixed_nodes))
    inp.append("*BOUNDARY")
    inp.append("FIXED,1,3")  # fix x,y,z (1,2,3 directions)
    
    # Load: pressure on face at x=length (distributed force)
    # Force / area = pressure
    area = width * height
    pressure = force_n / area  # MPa
    inp.append("*SURFACE, NAME=LOADFACE, TYPE=ELEMENT")
    for ix in range(nx):
        for iy in range(ny):
            for iz in range(nz):
                if ix == nx - 1:  # elements at x=length
                    elem = (ix * ny * nz) + (iy * nz) + iz + 1
                    inp.append(f"{elem},SP")  # face 2 (x=+1)
    inp.append("*DLOAD")
    inp.append(f"LOADFACE,P,{pressure:.6f}")
    
    # Request element stress output
    inp.append("*EL PRINT, ELSET=BEAM")
    inp.append("S")
    
    inp.append("*STEP")
    inp.append("*STATIC")
    inp.append("*END STEP")
    
    return "\n".join(inp)

def run_ccx(inp_content, basename="cantilever"):
    """Run Calculix solver on input."""
    with tempfile.TemporaryDirectory() as tmpdir:
        inp_path = os.path.join(tmpdir, f"{basename}.inp")
        with open(inp_path, 'w') as f:
            f.write(inp_content)
        
        # Run ccx
        cmd = ["ccx", "-i", basename]
        result = subprocess.run(
            cmd,
            cwd=tmpdir,
            capture_output=True,
            text=True
        )
        
        # Parse .dat file for stress
        dat_path = os.path.join(tmpdir, f"{basename}.dat")
        if os.path.exists(dat_path):
            with open(dat_path, 'r') as f:
                dat_lines = f.readlines()
            
            # Find element stress output block
            in_stress_block = False
            s11_values = []
            for line in dat_lines:
                line = line.strip()
                if line.startswith("STRESS"):
                    in_stress_block = True
                    continue
                if in_stress_block and line.startswith("1P"):
                    # Line looks like: "1P 1.23456E+02 2.34567E+02 ..."
                    parts = line.split()
                    if len(parts) >= 2:
                        try:
                            # S11 is the second column (index 1)
                            s11 = float(parts[1])
                            s11_values.append(s11)
                        except ValueError:
                            pass
                if line.startswith("DISPLACEMENT") or line.startswith("REACTION"):
                    in_stress_block = False
            
            if s11_values:
                max_s11 = max(s11_values, key=abs)
                avg_s11 = np.mean(s11_values)
                return max_s11, avg_s11, result.stderr
        
        return None, None, result.stderr

def analytical_bending_stress(width, height, length, force):
    """Analytical bending stress formula."""
    moment = force * length
    c = height / 2
    I = width * height**3 / 12
    return moment * c / I

if __name__ == "__main__":
    print("Direct Calculix cantilever beam validation")
    print("==========================================")
    
    # Dimensions matching crank pin
    width = 70.0   # mm
    height = 30.0  # mm
    length = 47.5  # mm (stroke)
    force = 180000.0  # N
    
    # Generate input
    inp = create_cantilever_inp(width, height, length, force)
    print(f"Generated .inp with {len(inp.splitlines())} lines")
    
    # Analytical
    sigma_anal = analytical_bending_stress(width, height, length, force)
    print(f"Analytical bending stress: {sigma_anal:.2f} MPa")
    
    # Run Calculix
    print("Running ccx...")
    s11_max, s11_avg, stderr = run_ccx(inp)
    
    if s11_max is not None:
        print(f"FEA max S11 stress: {s11_max:.2f} MPa")
        print(f"FEA avg S11 stress: {s11_avg:.2f} MPa")
        diff_pct = abs(s11_max - sigma_anal) / sigma_anal * 100
        print(f"Difference (max vs analytical): {diff_pct:.1f}%")
        if diff_pct < 15:
            print("✅ FEA matches analytical within 15% – validation passed.")
        else:
            print("⚠️  Large discrepancy – check model.")
    else:
        print("❌ Failed to parse results.")
        if stderr:
            print("stderr:", stderr[:500])